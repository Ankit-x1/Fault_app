<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMU Fault Detection App</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f7f6; color: #333; }
        .container { max-width: 900px; margin: 30px auto; background: #fff; padding: 30px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        h1, h2 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; margin-bottom: 20px; }
        button { padding: 10px 20px; margin-right: 10px; background-color: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; transition: background-color 0.3s ease; }
        button:hover { background-color: #2980b9; }
        textarea { width: 100%; padding: 12px; margin-top: 15px; border: 1px solid #ccc; border-radius: 5px; min-height: 120px; font-size: 14px; resize: vertical; }
        .response { background-color: #e9ecef; padding: 15px; margin-top: 25px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; border-left: 5px solid #3498db; }
        .success { color: #28a745; font-weight: bold; }
        .error { color: #dc3545; font-weight: bold; }
        .info { color: #17a2b8; font-weight: bold; }
        label { display: block; margin-top: 15px; font-weight: bold; }
        input[type="text"] { width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 5px; margin-top: 5px; }
        .feature-input-group { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
        .feature-input-group div { flex: 1 1 150px; }
        .feature-input-group input { width: calc(100% - 22px); }
    </style>
</head>
<body>
    <div class="container">
        <h1>IMU Fault Detection Application</h1>

        <section>
            <h2>Train Model</h2>
            <p>Click the button below to train the autoencoder model on simulated IMU (Accelerometer and Gyroscope) sensor data. This might take a few minutes (approx. 100 epochs). A new model (PyTorch & ONNX) and scaler will be saved.</p>
            <button id="trainButton">Start Training</button>
            <div id="trainResponse" class="response"></div>
            <div style="width: 80%; margin: 20px auto;">
                <canvas id="trainingLossChart"></canvas>
            </div>
        </section>

        <hr style="margin: 30px 0;">

        <section>
            <h2>Detect Faults (Full Sequence)</h2>
            <p>Enter exactly <span id="sequenceLengthDisplay">{{ SEQUENCE_LENGTH }}</span> lines of sensor readings. Each line must contain <span id="nFeaturesDisplay">{{ N_FEATURES }}</span> comma-separated values for the following features: {{ SENSOR_FEATURES_STRING }}.</p>
            <p>Example for {{ N_FEATURES }} features and {{ SEQUENCE_LENGTH }} sequence length (repeat 50 times):</p>
            <pre>0.1,0.2,9.8,0.01,0.02,0.005
0.1,0.2,9.8,0.01,0.02,0.005
...</pre>
            <textarea id="sensorReadings" placeholder="Enter {{ SEQUENCE_LENGTH }} lines of sensor readings"></textarea>
            <button id="detectButton">Detect Anomalies</button>
            <div id="detectResponse" class="response"></div>
            <div style="width: 80%; margin: 20px auto;">
                <canvas id="sensorReconstructionChart"></canvas>
            </div>
            <div style="width: 80%; margin: 20px auto;">
                <canvas id="reconstructionLossChart"></canvas>
            </div>
        </section>
    </div>

    <script>
        // Dynamically load configuration from the backend
        const SEQUENCE_LENGTH = {{ SEQUENCE_LENGTH }};
        const N_FEATURES = {{ N_FEATURES }};
        const SENSOR_FEATURES_STRING = "{{ SENSOR_FEATURES_STRING }}";

        document.getElementById('trainButton').addEventListener('click', async () => {
            const responseDiv = document.getElementById('trainResponse');
            responseDiv.innerHTML = '<span class="info">Training model... Please wait. This may take a while.</span>';
            responseDiv.className = 'response info';

            try {
                const response = await fetch('/api/train', { method: 'POST' });
                const data = await response.json();
                if (data.status === 'success') {
                    responseDiv.innerHTML = `<span class="success">Training successful!</span><br>${data.message}<br><pre>${data.log}</pre>`;
                    responseDiv.className = 'response success';

                    // Render chart
                    const ctx = document.getElementById('trainingLossChart').getContext('2d');
                    if (window.trainingChart) {
                        window.trainingChart.destroy(); // Destroy previous chart instance if it exists
                    }
                    window.trainingChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: data.losses.map((_, i) => `Epoch ${i + 1}`),
                            datasets: [{
                                label: 'Training Loss',
                                data: data.losses,
                                borderColor: 'rgb(75, 192, 192)',
                                tension: 0.1,
                                fill: false
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Model Training Loss Over Epochs'
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Epoch'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Loss'
                                    }
                                }
                            }
                        }
                    });

                } else {
                    responseDiv.innerHTML = `<span class="error">Training failed:</span> ${data.message}`;
                    responseDiv.className = 'response error';
                    if (window.trainingChart) {
                        window.trainingChart.destroy(); // Clear chart on error
                    }
                }
            } catch (error) {
                responseDiv.innerHTML = `<span class="error">An error occurred during training:</span> ${error.message}`;
                responseDiv.className = 'response error';
            }
        });

        document.getElementById('detectButton').addEventListener('click', async () => {
            const responseDiv = document.getElementById('detectResponse');
            responseDiv.innerHTML = '<span class="info">Detecting anomalies...</span>';
            responseDiv.className = 'response info';

            const readingsInput = document.getElementById('sensorReadings').value;
            const lines = readingsInput.trim().split('\\n').filter(line => line.trim() !== '');

            if (lines.length === 0) {
                responseDiv.innerHTML = `<span class="error">Please enter sensor readings.</span>`;
                responseDiv.className = 'response error';
                return;
            }

            if (lines.length !== SEQUENCE_LENGTH) {
                responseDiv.innerHTML = `<span class="error">Please enter exactly ${SEQUENCE_LENGTH} lines of sensor readings. You entered ${lines.length}.</span>`;
                responseDiv.className = 'response error';
                return;
            }

            const sensorReadings2D = [];
            for (const line of lines) {
                const values = line.split(',').map(Number).filter(n => !isNaN(n));
                if (values.length !== N_FEATURES) {
                    responseDiv.innerHTML = `<span class="error">Each line must contain exactly ${N_FEATURES} comma-separated sensor readings. Found ${values.length} in a line.</span>`;
                    responseDiv.className = 'response error';
                    return;
                }
                sensorReadings2D.push(values);
            }

            try {
                const response = await fetch('/api/detect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sensor_readings: sensorReadings2D }) // Sending as 2D array of floats
                });
                const data = await response.json();
                
                if (data.status === 'success') {
                    // Extract data for charts
                    const inputData = data.input_data;
                    const reconstructionData = data.reconstruction_data;
                    const reconstructionLoss = data.reconstruction_loss;
                    const anomalyThreshold = data.anomaly_threshold;
                    const anomalyIndices = data.anomaly_indices;

                    let resultHtml = `<span class="success">Detection successful!</span><br>`;
                    resultHtml += `Anomaly Threshold: ${anomalyThreshold ? anomalyThreshold.toFixed(4) : 'N/A'}<br>`;
                    if (data.number_of_anomalies > 0) {
                        resultHtml += `Number of Anomalies Found: ${data.number_of_anomalies}<br>`;
                        resultHtml += `Anomaly Indices: ${anomalyIndices.join(', ')}`;
                    } else {
                        resultHtml += `No anomalies detected.`;
                    }
                    responseDiv.innerHTML = resultHtml;
                    responseDiv.className = 'response success';

                    // --- Render Sensor Readings vs. Reconstruction Chart ---
                    const ctx1 = document.getElementById('sensorReconstructionChart').getContext('2d');
                    if (window.sensorReconstructionChart) {
                        window.sensorReconstructionChart.destroy();
                    }

                    // Prepare datasets for sensor readings vs reconstruction
                    const labels = Array.from({ length: SEQUENCE_LENGTH }, (_, i) => i);
                    const datasets = [];
                    for (let i = 0; i < N_FEATURES; i++) {
                        datasets.push({
                            label: `Input Feature ${i+1} (${SENSOR_FEATURES_STRING.split(', ')[i]})`,
                            data: inputData.map(row => row[i]),
                            borderColor: `hsl(${i * (360 / N_FEATURES)}, 70%, 50%)`,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 1 // Smaller points for clarity
                        });
                        datasets.push({
                            label: `Recon Feature ${i+1}`,
                            data: reconstructionData.map(row => row[i]),
                            borderColor: `hsl(${i * (360 / N_FEATURES)}, 70%, 80%)`,
                            borderDash: [5, 5], // Dashed line for reconstruction
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0 // No points for reconstruction
                        });
                    }
                    window.sensorReconstructionChart = new Chart(ctx1, {
                        type: 'line',
                        data: { labels, datasets },
                        options: {
                            responsive: true,
                            plugins: {
                                title: { display: true, text: 'Sensor Readings vs. Reconstruction' }
                            },
                            scales: {
                                x: { title: { display: true, text: 'Time Step' } },
                                y: { title: { display: true, text: 'Value' } }
                            }
                        }
                    });


                    // --- Render Reconstruction Error vs. Threshold Chart ---
                    const ctx2 = document.getElementById('reconstructionLossChart').getContext('2d');
                    if (window.reconstructionLossChart) {
                        window.reconstructionLossChart.destroy();
                    }

                    const anomalyPoints = anomalyIndices.map(index => ({ x: index, y: reconstructionLoss[index] }));

                    window.reconstructionLossChart = new Chart(ctx2, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Reconstruction Loss',
                                data: reconstructionLoss,
                                borderColor: 'rgb(255, 99, 132)',
                                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                fill: true,
                                tension: 0.1,
                                pointRadius: 3
                            }, {
                                label: 'Anomaly Threshold',
                                data: Array(SEQUENCE_LENGTH).fill(anomalyThreshold),
                                borderColor: 'rgb(54, 162, 235)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0
                            }, {
                                label: 'Anomalies',
                                data: anomalyPoints.map(p => ({x: p.x, y: p.y})),
                                backgroundColor: 'rgb(255, 0, 0)',
                                borderColor: 'rgb(255, 0, 0)',
                                pointRadius: 8,
                                pointStyle: 'rectRot',
                                showLine: false
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                title: { display: true, text: 'Reconstruction Error and Anomaly Threshold' }
                            },
                            scales: {
                                x: { title: { display: true, text: 'Time Step' } },
                                y: { title: { display: true, text: 'Loss Value' } }
                            }
                        }
                    });

                } else {
                    responseDiv.innerHTML = `<span class="error">Detection failed:</span> ${data.message}`;
                    responseDiv.className = 'response error';
                    if (window.sensorReconstructionChart) window.sensorReconstructionChart.destroy();
                    if (window.reconstructionLossChart) window.reconstructionLossChart.destroy();
                }            } catch (error) {
                responseDiv.innerHTML = `<span class="error">An error occurred during detection:</span> ${error.message}`;
                responseDiv.className = 'response error';
            }
        });
    </script>
</body>
</html>